//! Electronic Design Automation (EDA) for modern Printed Circuit Board Design
//!
//! Enhancing Engineer's Productivity and Versatility --
//! Programmatically Generating Libraries and Circuits.
//!
//! Atlantix-EDA enables electronic engineers to have fully customizable, rich libraries to employ in designs.
//! The Atlantix-EDA software tool suite *value position* is based upon programmatically generated libraries for PCB Design
//! with the advantages of:
//!
//!   - Rapid design creation with consistant and comprehensive PCB libraries.
//!
//!   - Higher productivity for individual engineers doing schematic, pcb, firmware, etc.
//!
//!   - Versatile and flexible, as the libraries are programmatically generated by this software.
//!
//! ## Software
//!
//! This software platform is built with the [Rust](https://www.rust-lang.org/) programming language, offering a very robust
//! systems programming language that is type and thread safe. Rust was chosen as the software for Atlantix-EDA
//! because of these features and a forward looking vision incorprating advanced capabilities.
//!
//! # License
//!
//! Licensed under GNU General Public License (GPL).
//! Copyright, 206-2020, Atlantix-EDA, Atlantix Engineering <fpga@atlantixeng.com>
//!
//! # Integration
//!
//! Altium for example has the database import described
//! here:   
//!
//! <https://www.altium.com/documentation/altium-designer/working-with-database-libraries-ad>
//!
//! Other tools such as KiCad, Fusion360(Eagle), Cadence Allegro, and Mentor PADS have not
//! been tested with the current Rust version of the software.
//! PADS was tested with an older version of this software so it should easily be adopted.
//! Tools such as the [KiCad]( https://gitlab.com/kicad/libraries/kicad-library-utils) generator functionality could
//! be replaced by Atlantix-EDA generate module, with the help of templating to take care of
//! boilerplate code in the component::Resistor library. A template engine such as [Askama](https://djc.github.io/askama/) would be a good
//! approach.
//!
//! Overall, component::Resistor libraries for Altium are included as part of this repo that include
//! every E-96 value from 0201 to 2512, which is over 5,000 parts.
//!
//! # Background
//!
//! For a complete component::Resistor library from 0201 to 2512 in the E-96 1% series there are 5,184 component::Resistor values. The ability to generate these libraries on the fly
//! and change any data associated with each part is quite powerful.
//!
//! The use of Atlantix-EDA to generate the component::Resistor library enables engineers developing in tools such as Altium, KiCad, etc. to have a comprehensive library 
//! available to them. This library enables quicker design cycles by
//! eliminating part creation and more robust design as BOM generation from the schematic will be accurate and true.
//!
//! ![image](../table.jpg)
//!
//! A history and more complete background of the [component::Resistor series.](https://en.wikipedia.org/wiki/E_series_of_preferred_numbers "Wikipedia component::Resistor series background")
//!
//!
//! ## Basic usage example
//! This basic example shows the generation of a 0603 library with
//! the decades ranging from 1 ohm to 1 Meg-Ohm
//!
//! ```
//! let decades = [1,10,100,1000,10000,100000];
//! let mut r0603 = generate::component::Resistor::new(96, "0603".to_string());
//!
//!	for decade in decades.iter() {
//!		r0603.generate(*decade);
//!	}
//! ```
//! ## Detailed usage example
//! The code below shows how to actually instantiate the component::Resistor object and generate
//! values across several decade values while writing to a file, which is then imported
//! by Altium or another tool.
//!
//! ```
//! fn main() {
//! 		let decades = [1,10,100,1000,10000,100000];
//!			let mut name_0402 : String = " ".to_string();
//!
//!			let mut r0402 = generate::component::Resistor::new(96, "0402".to_string());
//!
//!			for decade in decades.iter() {
//!				name_0402 = r0402.generate(*decade);
//!			}
//!
//! 		let mut file = OpenOptions::new()
//!                       .write(true)
//!                       .truncate(true)
//!                       .open("data.txt")
//!                       .expect("cannot open file");
//!
//!			file.write_all(name_0402.as_bytes()).expect("write failed");
//!
//!			println!("** Success::0402 component::Resistor generation.");
//! 	}
//! ```
//!

//-----------------------------------------------------------------------------------
// Licensed under GNU General Public License (GPL).
// Copyright, 206-2020, Atlantix-EDA, Atlantix Engineering <fpga@atlantixeng.com>
//-----------------------------------------------------------------------------------

use std::fs::OpenOptions;
use std::io::prelude::*;


//============================================================
//  Main::Creating Programmatically Generated component::Resistor Library
//============================================================

/// The main module which instantiates the generate module as an object. The generator can yield values over decade ranges.
fn main() -> std::io::Result<()> {
    //let decades = [1,10,100,1000,10000,100000];
    let decades = [1, 10, 100, 1000, 10000, 100000];
    let mut name_0402: String = " ".to_string();
    let mut name_0603: String = " ".to_string();
    let mut name_0805: String = " ".to_string();
    let mut name_1206: String = " ".to_string();
    let mut name_1210: String = " ".to_string();

    //--------------------------------------------------------------

    let mut r0402 = component::Resistor::new(96, "0402".to_string());
    for decade in decades.iter() {
        name_0402 = r0402.generate(*decade);
        //println!("{ }",name_0402)
    }

    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open("./outputs/data.txt")
        .expect("cannot open file");

    file.write_all("Part,Description,Value,Case,Power,Supplier 1,Supplier Part Number 1,Library Path,Library Ref,Footprint Path,Footprint Ref,Company,Comment \r\n".as_bytes()).expect("write failed");

    file.write_all(name_0402.as_bytes()).expect("write failed");
    println!("** Success::0402 component::Resistor E-96 series generation (1 Ohm to 1 MOhm).\r\n");

    //--------------------------------------------------------------

    let mut r0603 = component::Resistor::new(96, "0603".to_string());
    for decade in decades.iter() {
        name_0603 = r0603.generate(*decade);
        //println!("{ }",name_0603)
    }
    file.write_all(name_0603.as_bytes()).expect("write failed");
    println!("** Success::0603 component::Resistor E-96 series generation (1 Ohm to 1 MOhm).\r\n");

    //--------------------------------------------------------------

    let mut r0805 = component::Resistor::new(96, "0805".to_string());
    for decade in decades.iter() {
        name_0805 = r0805.generate(*decade);
        //println!("{}",name_0805);
    }
    file.write_all(name_0805.as_bytes()).expect("write failed");
    println!("** Success::0805 component::Resistor E-96 series generation (1 Ohm to 1 MOhm).\r\n");

    //--------------------------------------------------------------

    let mut r1206 = component::Resistor::new(96, "1206".to_string());
    for decade in decades.iter() {
        name_1206 = r1206.generate(*decade);
        //println!("{}",name_0805);
    }
    file.write_all(name_1206.as_bytes()).expect("write failed");
    println!("** Success::1206 component::Resistor E-96 series generation (1 Ohm to 1 MOhm).\r\n");

    //--------------------------------------------------------------

    let mut r1210 = component::Resistor::new(96, "1210".to_string());
    for decade in decades.iter() {
        name_1210 = r1210.generate(*decade);
        //println!("{}",name_0805);
    }
    file.write_all(name_1210.as_bytes()).expect("write failed");
    println!("** Success::1210 component::Resistor E-96 series generation (1 Ohm to 1 MOhm).\r\n");

    //--------------------------------------------------------------
    Ok(())
}
